// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Numerics;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;

#if !NET6_0_OR_GREATER
using MemoryMarshal = Win32.MemoryMarshal;
#endif

namespace Win32.Graphics.Direct3D.Dxc;

public static partial class Apis
{
	public static ref readonly Guid CLSID_DxcCompiler
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x93, 0x2D, 0xE2, 0x73,
				0xCE, 0xE6,
				0xF3, 0x47,
				0xB5,
				0xBF,
				0xF0,
				0x66,
				0x4F,
				0x39,
				0xC1,
				0xB0
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcLinker
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x87, 0x80, 0x6A, 0xEF,
				0xEA, 0xB0,
				0x56, 0x4D,
				0x9E,
				0x45,
				0xD0,
				0x7E,
				0x1A,
				0x8B,
				0x78,
				0x06
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcDiaDataSource
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x73, 0x6B, 0x1F, 0xCD,
				0xB0, 0x2A,
				0x4D, 0x48,
				0x8E,
				0xDC,
				0xEB,
				0xE7,
				0xA4,
				0x3C,
				0xA0,
				0x9F
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcCompilerArgs
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x82, 0xAE, 0x56, 0x3E,
				0x4D, 0x22,
				0x0F, 0x47,
				0xA1,
				0xA1,
				0xFE,
				0x30,
				0x16,
				0xEE,
				0x9F,
				0x9D
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcLibrary
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0xAF, 0xD6, 0x45, 0x62,
				0xE0, 0x66,
				0xFD, 0x48,
				0x80,
				0xB4,
				0x4D,
				0x27,
				0x17,
				0x96,
				0x74,
				0x8C
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcValidator
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x15, 0xE2, 0xA3, 0x8C,
				0x28, 0xF7,
				0xF3, 0x4C,
				0x8C,
				0xDD,
				0x88,
				0xAF,
				0x91,
				0x75,
				0x87,
				0xA1
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcAssembler
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x68, 0xDB, 0x28, 0xD7,
				0x03, 0xF9,
				0x80, 0x4F,
				0x94,
				0xCD,
				0xDC,
				0xCF,
				0x76,
				0xEC,
				0x71,
				0x51
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcContainerReflection
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x89, 0x44, 0xF5, 0xB9,
				0xB8, 0x55,
				0x0C, 0x40,
				0xBA,
				0x3A,
				0x16,
				0x75,
				0xE4,
				0x72,
				0x8B,
				0x91
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcOptimizer
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x9F, 0xD7, 0x2C, 0xAE,
				0x22, 0xCC,
				0x3F, 0x45,
				0x9B,
				0x6B,
				0xB1,
				0x24,
				0xE7,
				0xA5,
				0x20,
				0x4C
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcContainerBuilder
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0x94, 0x42, 0x13, 0x94,
				0x1F, 0x41,
				0x74, 0x45,
				0xB4,
				0xD0,
				0x87,
				0x41,
				0xE2,
				0x52,
				0x40,
				0xD2
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

	public static ref readonly Guid CLSID_DxcPdbUtils
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			ReadOnlySpan<byte> data = new byte[] {
				0xFB, 0x1D, 0x62, 0x54,
				0xCE, 0xF2,
				0x7E, 0x45,
				0xAE,
				0x8C,
				0xEC,
				0x35,
				0x5F,
				0xAE,
				0xEC,
				0x7C
			};

			Debug.Assert(data.Length == Unsafe.SizeOf<Guid>());
			return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
		}
	}

}

#region Enums
/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_CP"]/*' />
/// <unmanaged>DXC_CP</unmanaged>
public enum DxcCp : uint
{
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_CP::DXC_CP_ACP"]/*' />
	/// <unmanaged>DXC_CP_ACP</unmanaged>
	Acp = 0,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_CP::DXC_CP_UTF16"]/*' />
	/// <unmanaged>DXC_CP_UTF16</unmanaged>
	Utf16 = 1200,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_CP::DXC_CP_UTF8"]/*' />
	/// <unmanaged>DXC_CP_UTF8</unmanaged>
	Utf8 = 65001,
}

/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND"]/*' />
/// <unmanaged>DXC_OUT_KIND</unmanaged>
public enum DxcOutKind : int
{
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_NONE"]/*' />
	/// <unmanaged>DXC_OUT_NONE</unmanaged>
	None = 0,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_OBJECT"]/*' />
	/// <unmanaged>DXC_OUT_OBJECT</unmanaged>
	Object = 1,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_ERRORS"]/*' />
	/// <unmanaged>DXC_OUT_ERRORS</unmanaged>
	Errors = 2,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_PDB"]/*' />
	/// <unmanaged>DXC_OUT_PDB</unmanaged>
	Pdb = 3,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_SHADER_HASH"]/*' />
	/// <unmanaged>DXC_OUT_SHADER_HASH</unmanaged>
	ShaderHash = 4,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_DISASSEMBLY"]/*' />
	/// <unmanaged>DXC_OUT_DISASSEMBLY</unmanaged>
	Disassembly = 5,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_HLSL"]/*' />
	/// <unmanaged>DXC_OUT_HLSL</unmanaged>
	Hlsl = 6,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_TEXT"]/*' />
	/// <unmanaged>DXC_OUT_TEXT</unmanaged>
	Text = 7,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_REFLECTION"]/*' />
	/// <unmanaged>DXC_OUT_REFLECTION</unmanaged>
	Reflection = 8,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_ROOT_SIGNATURE"]/*' />
	/// <unmanaged>DXC_OUT_ROOT_SIGNATURE</unmanaged>
	RootSignature = 9,
	/// <include file='../Direct3D.xml' path='doc/member[@name="DXC_OUT_KIND::DXC_OUT_EXTRA_OUTPUTS"]/*' />
	/// <unmanaged>DXC_OUT_EXTRA_OUTPUTS</unmanaged>
	ExtraOutputs = 10,
}

#endregion Enums

#region Generated Enums
/// <unmanaged>DXC_HASHFLAG</unmanaged>
[Flags]
public enum DxcHashFlags : uint
{
	None = 0,
	/// <unmanaged>DXC_HASHFLAG_INCLUDES_SOURCE</unmanaged>
	IncludesSource = 1,
}

/// <unmanaged>DxcValidatorFlags</unmanaged>
[Flags]
public enum DxcValidatorFlags : uint
{
	None = 0,
	/// <unmanaged>DxcValidatorFlags_Default</unmanaged>
	Default = 0,
	/// <unmanaged>DxcValidatorFlags_InPlaceEdit</unmanaged>
	InPlaceEdit = 1,
	/// <unmanaged>DxcValidatorFlags_RootSignatureOnly</unmanaged>
	RootSignatureOnly = 2,
	/// <unmanaged>DxcValidatorFlags_ModuleOnly</unmanaged>
	ModuleOnly = 4,
	/// <unmanaged>DxcValidatorFlags_ValidMask</unmanaged>
	ValidMask = 7,
}

/// <unmanaged>DxcVersionInfoFlags</unmanaged>
[Flags]
public enum DxcVersionInfoFlags : uint
{
	/// <unmanaged>DxcVersionInfoFlags_None</unmanaged>
	None = 0,
	/// <unmanaged>DxcVersionInfoFlags_Debug</unmanaged>
	Debug = 1,
	/// <unmanaged>DxcVersionInfoFlags_Internal</unmanaged>
	Internal = 2,
}

#endregion Generated Enums

#region Structs
/// <include file='../Direct3D.xml' path='doc/member[@name="DxcShaderHash"]/*' />
/// <unmanaged>DxcShaderHash</unmanaged>
public partial struct DxcShaderHash
{
	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcShaderHash::Flags"]/*' />
	public DxcHashFlags Flags;

	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcShaderHash::HashDigest"]/*' />
	public unsafe fixed byte HashDigest[16];
}

/// <include file='../Direct3D.xml' path='doc/member[@name="DxcBuffer"]/*' />
/// <unmanaged>DxcBuffer</unmanaged>
public partial struct DxcBuffer
{
	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcBuffer::Ptr"]/*' />
	public unsafe void* Ptr;

	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcBuffer::Size"]/*' />
	public nuint Size;

	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcBuffer::Encoding"]/*' />
	public uint Encoding;
}

/// <include file='../Direct3D.xml' path='doc/member[@name="DxcDefine"]/*' />
/// <unmanaged>DxcDefine</unmanaged>
public partial struct DxcDefine
{
	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcDefine::Name"]/*' />
	public unsafe ushort* Name;

	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcDefine::Value"]/*' />
	public unsafe ushort* Value;
}

/// <include file='../Direct3D.xml' path='doc/member[@name="DxcArgPair"]/*' />
/// <unmanaged>DxcArgPair</unmanaged>
public partial struct DxcArgPair
{
	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcArgPair::pName"]/*' />
	public unsafe ushort* pName;

	/// <include file='../Direct3D.xml' path='doc/member[@name="DxcArgPair::pValue"]/*' />
	public unsafe ushort* pValue;
}

#endregion Structs

#region COM Types
#endregion Com Types

#region Functions
public static unsafe partial class Apis
{
	[DllImport("dxcompiler", ExactSpelling = true)]
	public static extern HResult DxcCreateInstance(Guid* rclsid, Guid* riid, void** ppv);

	[DllImport("dxcompiler", ExactSpelling = true)]
	public static extern HResult DxcCreateInstance2(Com.IMalloc* pMalloc, Guid* rclsid, Guid* riid, void** ppv);

}
#endregion Functions
